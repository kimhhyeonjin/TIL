# APS(Algorithm Problem Solving) 응용

### 복잡도 분석

- 알고리즘 효율
  
  - 공간적 효율성과 시간적 효율성
    
    - 공간적 효율성: 연산량 대비 얼마나 적은 메모리 공간을 요하는가
    
    - 시간적 효율성: 연산량 대비 얼마나 적은 시간을 요하는가
    
    - 복잡도가 높을수록 효율성은 저하됨
  
  - 시간적 복잡도 분석
    
    - 하드웨어 환경에 따라 처리시간이 달라짐
      
      - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
      
      - 입출력 장비의 성능, 공유 여부
    
    - 소프트웨어 환경에 따라 처리 시간이 달라짐
      
      - 프로그램 언어의 종류
      
      - 운영체제, 컴파일러의 종류
    
    - 이러한 환경적 차이로 인해 분석이 어려움

- 복잡도의 점근적 표기
  
  - 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식
  
  - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용
  
  - 입력 크기 n 이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법

- `Big Oh` 표기
  
  - 복잡도의 점근적 상한
  
  - 최악의 경우 걸리는 시간
  
  - 자주 사용하는 `Big Oh` 표기
    
    | Big Oh   | 시간                         |
    |:--------:|:--------------------------:|
    | O(1)     | 상수 시간 (Constant time)      |
    | O(logn)  | 로그 시간 (Logarithmic time)   |
    | O(n)     | 선형 시간 (Linear time)        |
    | O(nlogn) | 로그 선형 시간 (Log-linear time) |
    | O(n^2)   | 제곱 시간 (Quadratic time)     |
    | O(n^3)   | 세제곱 시간 (Cubic time)        |
    | O(2^n)   | 지수 시간 (Exponential time)   |

- `Big Omega` 표기
  
  - 복잡도의 점근적 하한
  
  - 최고의 경우 걸리는 시간

- `Big Theta` 표기
  
  - `Big Oh` 표기와 `Big Omega` 표기가 같은 경우 사용

- 왜 효율적인 알고리즘이 필요한가
  
  - 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음
  
  - 값비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적임

### 비트 연산

- 비트 연산자
  
  | 연산자 | 연산자의 기능                                      |
  |:---:|:--------------------------------------------:|
  | &   | 비트 단위로 AND 연산, (특정 비트를 0으로 만들 때 / 비트 검사)     |
  | or  | 비트 단위로 OR 연산, (특정 비트를 1으로 만들 때)              |
  | ^   | 비트 단위로 XOR 연산 (같으면 0 다르면 1), (특정 비트를 반전시킬 때) |
  | ~   | 피연산자의 모든 비트를 반전                              |
  | <<  | 피연산자의 비트 열을 왼쪽으로 이동                          |
  | >>  | 피연산자의 비트 열을 오른쪽으로 이동                         |

- 엔디안(Endianness)
  
  - 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법
  
  - 바이트 단위와 워드 단위를 변환하여 연산하여 속도를 향상시킬 때 오류를 발생시키지 않도록 주의
  
  - 빅 엔디안과 리틀 엔디안
    
    - 빅 엔디안(Big-endian)
      
      - 보통 큰 단위가 앞에 나옴
      
      - 네트워크
    
    - 리틀 엔디안(Little-endian)
      
      - 작은 단위가 앞에 나옴
      
      - 대다수 데스크탑 컴퓨터
    
    | 종류     | 0x1234의 표현 | 0x12345678의 표현 |
    |:------:|:----------:|:--------------:|
    | 빅 엔디안  | 12 34      | 12 34 56 78    |
    | 리틀 엔디안 | 34 12      | 78 56 34 12    |
  
  - 엔디안 확인 코드
    
    ```python
    import sys
    
    print(sys.byteorder)        # little
    ```

- 비트 연산
  
  ```python
  def Bbit_print(i):
      output = ''
      for j in range(7, -1, -1):
          output += '1' if i & (1 << j) else '0'
      print(output)
  
  for i in range(-5, 6):
      print(f'{i} = ', end='')
      Bbit_print(i)
  
  a = 0x10                # 0x로 시작하면 16진수
  x = 0x01020304
  print('{a} = ', end='')
  Bbit_print(a)
  print()
  print(f'{x} = ', end='')
  for i in range(0, 4):
      Bbit_print((x >> i*8) & 0xff)
  
  a = 0x86                # 10000110
  key = 0xAA              # 10101010
  print(f'a          ', end = '')
  Bbit_print(a)
  print(f'a^=key     ', end = '')
  a ^= key
  Bbit_print(a)
  
  # 비트를 거꾸로
  def ce1(n):
      return (n << 24 & 0xff000000) | (n << 8 & 0xff0000) | (n >> 8 & 0xff00) | (n >> 24 & 0xff)
  ```

### 진수

- 진수 변환
  
  - 타 진수 -> 10진수로 변환
    
    - (135)8 = 1 * 8^2 + 3 * 8^1 + 5 * 8^0 = (93)10
    
    - 소수점이 있을 때
      
      - (135.12)8 = 1 * 8^2 + 3 * 8^1 + 5 * 8^0 + 1 * 8^(-1) + 2 * 8^(-2) = (93.15625)10
  
  - 2진수, 8진수, 16진수 간 변환

- 컴퓨터에서의 음의 정수 표현 방법
  
  - 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환
  
  - 2의 보수: 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함
  
  - -6: 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 (부호와 절대값 표현)
    
    -6: 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 (1의 보수 표현)
    
    -6:  1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 (2의 보수 표현)

- 다른 진수를 표현할 때 사용하는 접두사
  
  - 2진수: 0b
  
  - 8진수: 0o
  
  - 16진수: 0x

- 10진수에서 다른 진수로 변환 (**문자열**로 변환됨, 접두사 포함)
  
  - `bin()`: 2진수
  
  - `oct()`: 8진수
  
  - `hex()`: 16진수

- 다른 진수의 **문자열**에서 10진수로 변환 (접두사 포함)
  
  - `int()`함수 이용
  
  - int('2진수 값', 2)
  
  - int('8진수 값', 8)
  
  - int('16진수 값', 16)

- 접두사 제외하고 추가하기
  
  - `format()` 함수 이용
  
  - 접두사 제외하기 (**문자열**로 변환됨)
    
    - format(10진수 값, 'b'): 2진수
    
    - format(10진수 값, 'o'): 8진수
    
    - format(10진수 값, 'x'): 16진수
    
    - format(10진수 값, 'd'): 10진수
  
  - 접두사 포함하기 (**문자열**로 변환됨)
    
    - format(10진수 값, '#b'): 2진수
    
    - format(10진수 값, '#o'): 8진수
    
    - format(10진수 값, '#x'): 16진수
    
    - format(10진수 값, '#d'): 10진수

- f-string을 이용해서 2진수 만들기
  
  - `f'{10진수 값:04b}'`: 10진수 값을 2진수로 만드는데 총 4자리가 되도록 하고 앞에 빈 공간이 있으면 0으로 채우도록 함
