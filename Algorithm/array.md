# 배열
## 알고리즘
### 알고리즘
 - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
 - 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
 - 알고리즘의 성능 분석
   - 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교
   - 알고리즘의 작업량을 표현할 때 시간복잡도로 표현
 - 시간 복잡도 (Time Complexity)
   - 실제 걸리는 시간을 측정
   - 실행되는 명령문의 개수를 계산
 - 빅-오 표기법(Big-Oh Notation)
   - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

## 배열
### 배열
 - 배열
   - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
### 정렬 (Sort)
 - 정렬
   - 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열하는 것

### 버블 정렬 (Bubble Sort)
 - 버블 정렬
   - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
   - 시간복잡도 : O(n^2)
     ```python
     def BubbleSort(arr):  # 정렬할 List, N 원소 수
         for i in range(len(arr)-1, 0, -1):  # 범위의 끝 위치
             for j in range(i):
                 if arr[j] > arr[j+1]:
                     arr[j], arr[j+1] = arr[j+1], arr[j]
     ```

### 카운팅 정렬 (Counting Sort)
 - 카운팅 정렬
   - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 알고리즘
   - 시간복잡도 : O(n+k)  # n은 리스트의 길이, k는 정수의 최대값
     ```python
     def Counting_Sort(arr):
         counts = [0] * (max(arr) + 1)  # 0자리를 만들어야 하기 때문
  
         for num in arr:
             counts[num] += 1
  
         for i in range(1, len(counts)):
             counts[i] += counts[i-1]  # 누적으로 표시
  
         result = [0] * (len(arr))
  
         for num in arr:
             idx = counts[num]
             result[idx - 1] = num  # index는 0부터 시작하기 때문에 idx - 1
             counts[num] -= 1
  
         print(result)
     ```

### 완전검색
 - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
 - 일반적으로 경우의 수가 상대적으로 적을 때 유용
 - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만 해답을 찾아내지 못할 확률이 작음

### 그리디 (Greedy Algorithm)
 - 그리디
   - 최적해를 구하는데 사용되는 근시안적인 방법
   - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
   - 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 그것이 최적이라는 보장은 없음


## 배열
### 2차원 배열
 - 2차원 배열의 선언
   ```python
   N = int(input())
   arr = [list(map(int, input().split())) for _ in range(N)]
   ```
 - 2차원 배열의 접근
   - 배열 순회
     - n X m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법
   - 행 우선 순회
     ```python
     # i행의 좌표
     # j열의 좌표
     for i in range(n):
         for j in range(m):
             Array[i][j]
     ```
   - 열 우선 순회
     ```python
     # i행의 좌표
     # j열의 좌표
     for j in range(m):
         for i in range(n):
             Array[i][j]
     ```
   - 지그재그 순회
     ```python
     # i행의 좌표
     # j열의 좌표
     for i in range(n):
         for j in range(m):
             Array[i][j + (m-1-2*j) * (i%2)]
             # 열 index가 짝수이면 Array[i][j]
             # 열 index가 홀수이면 Array[i][m-1-j]
     ```
   - 델타를 이용한 2차 배열 탐색
     ```python
     di = [0, 1, 0, -1]  # 상하좌우 설정
     dj = [1, 0, -1, 0]
     N = 2
     M = 4
     arr = [[1, 2, 3, 4], [5, 6, 7, 8]]
     
     
     for i in range(N):
         for j in range(M):
             for k in range(4):
                 for d in range(1, 3):  # 상하좌우 1칸, 2칸 이동하는 경우
                     ni = i + di[k]*d
                     nj = j + dj[k]*d
                     if 0<=ni<N and 0<=nj<M:
                         print(ni, nj)
     ```
### 부분집합 생성
 - 부분집합 합(Subset Sum) 문제
   - 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
 - 비트 연산자
   - 비트 연산자
     - `&` : 비트 단위로 AND 연산을 한다
     - `|` : 비트 단위로 OR 연산을 한다
     - `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다 (*2 한 것과 같음)
       - `1 << n` : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미
         - `1<<4`를 예시로 들면 1을 왼쪽으로 4번 이동시킨 것과 동일하여 10000(2)로 표현되고 이 값은 2^4와 같다
       - `<<`와 `+`가 있으면 +를 우선 계산
         - `1<<n+1`은 2^(n+1)과 같다
         - 만약 2^n + 1을 구하고 싶으면 `(1<<n) + 1`
     - `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다 (/2 한 것과 같음)
       - `1000>>2`는 0010(2)와 같음
   - & 연산자
     - `i & (1<<j)` : i의 j번째 비트가 1인지 아닌지를 검사
       > i의 j번째 비트가 1이면 결과가 1, 그렇지 않으면 결과가 0
       ```python
       arr = list(map(int, input().split()))
       n = len(arr)
       for j in range(1<<n):  # 부분집합의 개수 2^10의 범위에서
           sum_subset = []  # 부분집합 초기화
           total = 3  # total은 0이 아닌 수로 설정
           for k in range(n):  # 원소의 수만큼 비트를 비교
               if j & (1<<k):  # j의 k번 비트가 1인 경우
                   sum_subset.append(arr[k])  # 부분집합에 추가
                   # print(sum_subset)
                   for l in range(len(sum_subset)):  # 부분집합의 합 구하기
                       total += sum_subset[l]
           if total == 0:  # 만약 부분집합의 합이 0이면
               print(f'#{i} 1')  # 1을 출력
               break  # for문 빠져 나가기
       if total != 0:  # 부분집합의 합이 0이 아니면
           print(f'#{i} 0')  # 0을 출력
       ```
### 바이너리 서치 (Binary Search)
 - 검색(Search)
   - 검색
     - 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
     - 목적하는 탐색 키를 가진 항목을 찾는 것
 - 순차 검색(Sequential Search)
   - 일렬로 되어 있는 자료를 순서대로 검색하는 방법
   - 정렬되어 있지 않은 경우
     - 검색 과정
       - 첫번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다
       - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다
       - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
   - 정렬되어 있는 경우
     - 검색 과정
       - 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정
       - 자료를 순차적으로 검색하면서 키 값을 비교하여 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료
 - 이진 검색(Binary Search)
   - 검색 과정
     - 자료의 중앙에 있는 원소를 골라 중앙 원소의 값과 찾고자 하는 목표 값을 비교
     - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행
     - 찾고자 하는 값을 찾을 때까지 위의 과정을 반복
   - **자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요**
### 선택 정렬 (Selection Sort)
 - 선택 정렬
   - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
   - 정렬 과정
     - 주어진 리스트 중에서 최소값을 찾는다
     - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다
     - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다
   - 시간 복잡도 : O(n^2)
### 셀렉션 알고리즘 (Selection Algorithm)
 - 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
 - 선택 과정
   - 정렬 알고리즘을 이용하여 자료 정렬하기
   - 원하는 순서에 있는 원소 가져오기