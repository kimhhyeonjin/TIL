# Computational Thinking

## 1. 명제와 진리표

### 조건명제

- p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제

- p -> q (p이면 q이다.)
  
  | p   | q   | p -> q |
  |:---:|:---:|:------:|
  | T   | T   | T      |
  | T   | F   | F      |
  | F   | T   | T      |
  | F   | F   | T      |

> p가 F이면 p -> q는 무조건 T
> 
> q가 T이면 p -> q는 무조건 T

### 쌍방조건명제

- p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제

- p <-> q (p면 q고, q면 p이다.)
  
  | p   | q   | p <-> q |
  |:---:|:---:|:-------:|
  | T   | T   | T       |
  | T   | F   | F       |
  | F   | T   | F       |
  | F   | F   | T       |

### 조건명제의 역, 이, 대우

- 역: q -> p

- 이: ~p -> ~q

- 대우: ~q -> ~p
  
  | p   | q   | p -> q | q -> p | ~p -> ~q | ~q -> ~p |
  |:---:|:---:|:------:|:------:|:--------:|:--------:|
  | T   | T   | T      | T      | T        | T        |
  | T   | F   | F      | T      | T        | F        |
  | F   | T   | T      | F      | F        | T        |
  | F   | F   | T      | T      | T        | T        |

#### Q. 다음 명제의 진리표를 만드시오.

- p or (q -> ~p)
  
  | p   | q   | ~p  | (q -> ~p) | p and (q -> ~p) |
  |:---:|:---:|:---:|:---------:|:---------------:|
  | T   | T   | F   | F         | F               |
  | T   | F   | F   | T         | T               |
  | F   | T   | T   | T         | F               |
  | F   | F   | T   | T         | F               |

- ~(~p and q) or q
  
  - 항진명제
    
    | p   | q   | ~p  | (~p and q) | ~(~p and q) | ~(~p and q) or q |
    |:---:|:---:|:---:|:----------:|:-----------:|:----------------:|
    | T   | T   | F   | F          | T           | T                |
    | T   | F   | F   | F          | T           | T                |
    | F   | T   | T   | T          | F           | T                |
    | F   | F   | T   | F          | T           | T                |

- (~p or q) or (p and ~q)
  
  - 항진명제
    
    | p   | q   | ~p  | ~q  | (~p or q) | (p and ~q) | (~p or q) or (p and ~q) |
    |:---:|:---:|:---:|:---:|:---------:|:----------:|:-----------------------:|
    | T   | T   | F   | F   | T         | F          | T                       |
    | T   | F   | F   | T   | F         | T          | T                       |
    | F   | T   | T   | F   | T         | F          | T                       |
    | F   | F   | T   | T   | T         | F          | T                       |

- (~p or q) and (p and ~q)
  
  - 모순명제
    
    | p   | q   | ~p  | (~p or q) | ~q  | (p and ~q) | (~p or q) and (p and ~q) |
    |:---:|:---:|:---:|:---------:|:---:|:----------:|:------------------------:|
    | T   | T   | F   | T         | F   | F          | F                        |
    | T   | F   | F   | F         | T   | T          | F                        |
    | F   | T   | T   | T         | F   | F          | F                        |
    | F   | F   | T   | T         | T   | F          | F                        |

- (p and q) and (p and ~q)
  
  - 모순명제
    
    | p   | q   | ~q  | (p and q) | (p and ~q) | (p and q) and (p and ~q) |
    |:---:|:---:|:---:|:---------:|:----------:|:------------------------:|
    | T   | T   | F   | T         | F          | F                        |
    | T   | F   | T   | F         | T          | F                        |
    | F   | T   | F   | F         | F          | F                        |
    | F   | F   | T   | F         | F          | F                        |

- p and (p or q)
  
  - p와 동등함
    
    | p   | q   | (p or q) | p and (p or q) |
    |:---:|:---:|:--------:|:--------------:|
    | T   | T   | T        | T              |
    | T   | F   | T        | T              |
    | F   | T   | T        | F              |
    | F   | F   | F        | F              |

- ~(p and q)
  
  - ~p or ~q와 동등함
    
    | p   | q   | ~p  | ~q  | (~p or ~q) | (p and q) | ~(p and q) |
    |:---:|:---:|:---:|:---:|:----------:|:---------:|:----------:|
    | T   | T   | F   | F   | F          | T         | F          |
    | T   | F   | F   | T   | T          | F         | T          |
    | F   | T   | T   | F   | T          | F         | T          |
    | F   | F   | T   | T   | T          | F         | T          |

## 2. 수와 표현

### 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?

- 2^k - 1 >= n이 성립해야 함

- 즉, 2^k >= n + 1

- 즉, k >= log(n+1)

- 약 log n 비트가 필요 (컴퓨터 분야에서 로그의 밑은 항상 2)

### log n이란

- 2의 몇 제곱이 n이 되느냐의 답

- n을 표현하는데 몇 비트가 필요한가의 답

- 1로 시작해서 계속 2배를 할 때 몇 번 하면 n이 되느냐의 답

- n을 2로 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답

### Q.

- 2진수 표현에서 log n 비트로 표현할 수 있는 숫자 범위
  
  - 2^(log n) = n^(log 2) = n

- n이 충분히 큰 값일 때 어느 값이 더 큰가?
  
  - 2n / n^2
    
    - n^2
  
  - 2^(n * log n) / n!
    
    - 2^(n * log n) = 2^(log n^n) = n^n
    
    - 그러므로 2^(n * log n)이 더 큼

- 다음 함수의 역함수를 구하시오
  
  - f(x) = log(x-3) - 5
    
    f(x)^(-1) = 2^(x+5) + 3

## 3. 집합과 조합론

### 집합의 포함 관계

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명하려면 A의 임의의 원소가 B에 포함됨음 보이면 됨

- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 됨

### 조합론은 주로 경우의 수를 따지는 문제

## 4. 시간 복잡도

### Q. 다음 재귀식을 O() notation 수준으로 풀어라.

- T(n) = T(n-1) + 1, T(0) = 1
  
  ```
  T(n) = T(n-1) + 1
       = T(n-2) + 1 + 1
       ...
       = T(n-k) + k
       ...
       = T(0) + n
       = 1 + n
  그러므로 O(n)
  ```

- T(n) = T(n-1) + n, T(0) = 1
  
  ```
  T(n) = T(n-1) + n
       = T(n-2) + (n-1) + n
       ...
       = T(n-k) + (n-k+1) + ... + (n-1) + n
       ...
       = T(0) + 1 + ... + n
       = 1 + n*(n+1)/2
  그러므로 O(n^2)
  ```

- T(n) = T(n-1) + log n, T(0) = 1
  
  ```
  T(n) = T(n-1) + log n
       = T(n-2) + log (n-1) + log n
       = T(n-3) + log (n-2) + log (n-1) + log n
       ...
       = T(n-k) + log (n-k+1) + ... + log (n-1) + log n
       ...
       = T(0) + log 1 + ... + log (n-1) + log n
       = 1 + log (n!)
       <= 1 + log (n^n)
       = 1 + n*log n
  그러므로 O(n*log n)
  ```

- T(n) = T(n/2) + 1, T(1) = 1
  
  ```
  T(n) = T(n/2) + 1
       = T(n/4) + 1 + 1
       = T(n/8) + 1 + 1 + 1
       ...
       = T(n/(2^k)) + k
       = T(1) + k, (n=2^k인 경우)
       = 1 + log n
  그러므로 O(log n)
  ```

- T(n) = T(n/2) + n, T(1) = 1
  
  ```
  T(n) = T(n/2) + n
       = T((1/2)*(n/2)) + (n/2) + n
       = T(n/4) + (n/2) + n
       = T(n/8) + (n/4) + (n/2) + n
       ...
       = T(n/(2^k)) + (n/(2^(k-1))) + ... + (n/(2^2)) + (n/(2^1)) + (n/(2^0))
       = T(1) + n*(1 + 1/2 + ... + 1/(2^(k-1))),(n=2^k인 경우)
       = 1 + 2n
  그러므로 O(n)
  ```

- T(n) = 2T(n/2) + n, T(1) = 1
  
  ```
  T(n) = 2T(n/2) + n
       = 2 * (2T(n/4) + n/2) + n
       = 2 * (2*(2T(n/8) + n/4) + n/2) + n
       ...
       = (2^k)*T(n/(2^k)) + kn
       = nT(1) + n * log n, (n=2^k인 경우)
  그러므로 O(n * log n)
  ```

- T(n) = 3T(n/2) + n, T(1) = 1
  
  ```
  T(n) = 3T(n/2) + n
       = 3 * (3 * T(n/4) + n/2) + n
       = 3 * (3 * (3 * T(n/8) + n/4) + n/2) + n
       ...
       = (3^k)*T(n/(2^k)) + (((3/2)^k)-1)*n/((3/2)-1)
       = (3^k)*T(n/(2^k)) + 2n(((3/2)^k)-1)
       = (3^(log n))*T(1) + 2n*(((3^(log n))/n)-1), (n=2^k인 경우)
       = (3^(log n)) + 2*(3^(log n))
       = 3*(3^(log n)) - 2n
       = 3 * n^(log 3) - 2n
  그러므로 O(n^log 3)
  ```

- T(n) = T(n-1) + (1/n), T(1) = 1
  
  ```
  T(n) = T(n-1) + (1/n)
       = T(n-2) + (1/n) + (1/(n-1))
       = T(n-k) + (1/n) + ... + (1/(n-k+1))
       = 1 + 1/2 + 1/3 + ... + 1/n
  ```
  
  

## 5. 재귀

### 재귀

- 자기 자신을 호출하는 함수

- 수학적 귀납법을 증명할 때 사용 가능
  
  > n이 0일 때 문제를 풀 수 있다.
  > 
  > n-1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다.
  
  - 위 두 가지가 사실이면 모든 가능한 n에 대하여 문제를 풀 수 있다는 것이 사실

### Q. 다음 문제를 푸는 알고리즘을 슈도코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행하라

- 피보나치 수열: F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1
  
  ```
  # 슈도코드
  f(n)
      if n <= 2:
          return 1
      else:
          return f(n-1) + f(n-2)
  
  # 시간복잡도
  T(n) = T(n-1) + T(n-2) + 1
       < T(n-1) + T(n-1) + 1
       = 2T(n-1) + 1
       < 2 * (2T(n-2) + 1) + 1
       < 2 * (2 * (2T(n-3) + 1) + 1) + 1
       = (2^k) * T(n-k) + (2^(k-1) + ... + 2 + 1)
       = (2^k) * T(n-k) + (2^k - 1)
       = (2^k) * (T(n-k) + 1) - 1
       = 2^n - 1, (k=(n-1)인 경우)
  그러므로 O(2^n)
  ```
